Author: gregor herrmann <gregoa@debian.org>
Description: spelling fixes

--- a/lib/Config/Model/AnyId.pm
+++ b/lib/Config/Model/AnyId.pm
@@ -269,7 +269,7 @@
 
 =head1 Warp: dynamic value configuration
 
-The Warp functionnality enables an L<HashId|Config::Model::HashId> or
+The Warp functionality enables an L<HashId|Config::Model::HashId> or
 L<ListId|Config::Model::ListId> object to change its default settings
 (e.g. C<min>, C<max> or C<max_nb> parameters) dynamically according to
 the value of another C<Value> object. (See
@@ -824,7 +824,7 @@
 =head2 copy ( from_index, to_index )
 
 Deep copy an element within the hash or list. If the element contained
-by the hash or list is a node, all configuration informations are
+by the hash or list is a node, all configuration information is
 copied from one node to another.
 
 =cut
--- a/lib/Config/Model/AutoRead.pm
+++ b/lib/Config/Model/AutoRead.pm
@@ -556,7 +556,7 @@
 configuration data within the model (instead of writing dedicated perl
 code).
 
-With these specifications, all the configuration information are read
+With these specifications, all the configuration information is read
 during creation of a node.
 
 =begin comment
@@ -609,7 +609,7 @@
 After loading the data, the object registers itself to the
 instance. Then the user can call the C<write_back> method on the
 instance (See L<Config::Model::Instance>) to store all configuration
-informations back.
+information back.
 
 =head2 Built-in backend
 
@@ -811,7 +811,7 @@
 
 By default, the specifications are tried in order, until the first succeeds.
 
-When required by the user, all configuration informations are written
+When required by the user, all configuration information is written
 back using B<all> the write specifications. See
 L<Config::Model::Instance/write_back ( ... )> for details.
 
--- a/lib/Config/Model/CheckList.pm
+++ b/lib/Config/Model/CheckList.pm
@@ -191,7 +191,7 @@
 
 =item help
 
-Hash ref to provide informations on the check list items.
+Hash ref to provide information on the check list items.
 
 =item warp
 
--- a/lib/Config/Model/Instance.pm
+++ b/lib/Config/Model/Instance.pm
@@ -120,7 +120,7 @@
 			    type  => 1 } ],
 
 	 # a unique (instance wise) placeholder for various tree objects
-	 # to store informations
+	 # to store information
 	 safe => {
 		 } ,
 
@@ -224,7 +224,7 @@
 =head2 preset_start ()
 
 All values stored in preset mode are shown to the user as default
-values. This feature is usefull to enter configuration data entered by
+values. This feature is useful to enter configuration data entered by
 an automatic process (like hardware scan)
 
 =cut
@@ -488,7 +488,7 @@
 =head2 write_back ( ... )
 
 Try to run all subroutines registered with C<register_write_back> to
-write the configuration informations until one succeeds (returns
+write the configuration information until one succeeds (returns
 true). (See L<Config::Model::AutoRead> for details).
 
 You can specify here a pseudo root dir or another config dir to write
--- a/lib/Config/Model/Node.pm
+++ b/lib/Config/Model/Node.pm
@@ -213,13 +213,13 @@
 =head2 Element type
 
 Each element is declared with a list ref that contains all necessary
-informations:
+information:
 
   element => [ 
                foo => { ... }
              ]
 
-This most important informations from this hash ref is the mandatory 
+This most important information from this hash ref is the mandatory
 B<type> parameter. The I<type> type can be:
 
 =cut
@@ -1418,7 +1418,7 @@
 
 As configuration model are getting bigger, the load time of a tree
 gets longer. The L<Config::Model::AutoRead> class provides a way to
-load the configuration informations only when needed.
+load the configuration information only when needed.
 
 TBD
 
--- a/lib/Config/Model/ObjTreeScanner.pm
+++ b/lib/Config/Model/ObjTreeScanner.pm
@@ -454,7 +454,7 @@
     my @element_list= $node->get_element_name(for => $self->{experience}) ;
 
     # we could add here a "last element" call-back, but it's not
-    # very usefull if the last element is a hash.
+    # very useful if the last element is a hash.
     $self->{node_content_cb}->($self, $data_r,$node,@element_list) ;
 
     $self->{up_cb}->($self, $data_r,$node) ;
--- a/lib/Config/Model/Searcher.pm
+++ b/lib/Config/Model/Searcher.pm
@@ -334,9 +334,9 @@
 
 }
 
-=head2 choose( <choosen_element_name> )
+=head2 choose( <chosen_element_name> )
 
-Tell the search engine your choice. The choosen element name must be
+Tell the search engine your choice. The chosen element name must be
 one of the possibilities given by L</"next_step()">.
 
 =cut
@@ -401,8 +401,8 @@
 
 	# gobble next_class for warped_node element
 	if (defined $data->{next_class}) {
-	    my $choosen_class = $next_node->config_class_name ;
-	    $data = $data->{next_class}{$choosen_class} ;
+	    my $chosen_class = $next_node->config_class_name ;
+	    $data = $data->{next_class}{$chosen_class} ;
 	    unless (defined $data) {
 		Config::Model::Exception::User
 		    -> throw (
--- a/lib/Config/Model/Value.pm
+++ b/lib/Config/Model/Value.pm
@@ -89,7 +89,7 @@
 =item *
 
 upstream default parameter: specifies a default value that will be
-used by the application when no informations is provided in the
+used by the application when no information is provided in the
 configuration file. This upstream_default value will not written in
 the configuration files. Only the C<fetch_standard> method will return
 the builtin value. This parameter was previously refered as
@@ -1081,7 +1081,7 @@
 mandatory values.
 
 When the 2nd parameter is non null, check will not try to get extra
-informations from the tree. This is required in some cases to avoid
+information from the tree. This is required in some cases to avoid
 loops in check, get_info, get_warp_info, re-check ...
 
 In scalar context, return 0 or 1.
--- a/t/search_element.t
+++ b/t/search_element.t
@@ -170,10 +170,10 @@
 is_deeply($step, [qw/olist slave_y std_id warp/],'check first step') ;
 
 my $obj = $searcher->choose('warp') ;
-is($obj->name,'warp', 'check choosen object') ;
+is($obj->name,'warp', 'check chosen object') ;
 
 my $target = $searcher->auto_choose(sub{}, sub {}) ;
-is($target->name,'warp X', 'check auto choosen object for X') ;
+is($target->name,'warp X', 'check auto chosen object for X') ;
 
 $step = $searcher->next_step() ;
 is_deeply($step, [],'check that no more steps are left') ;
@@ -183,7 +183,7 @@
 $searcher = $root->searcher->prepare(element => 'aa');
 $searcher->choose('warp') ;
 $target = $searcher->auto_choose(sub{}, sub {}) ;
-is($target->name,'warp sub_slave aa', 'check auto choosen object for aa') ;
+is($target->name,'warp sub_slave aa', 'check auto chosen object for aa') ;
 
 # try choose_next
 $searcher = $root->searcher->prepare(element => 'aa');
@@ -191,7 +191,7 @@
 $step = $searcher->next_choice() ;
 is_deeply($step, [],'check that no more steps are left after next_choice') ;
 $target = $searcher->current_object ;
-is($target->name,'warp sub_slave aa', 'check choosen object for aa') ;
+is($target->name,'warp sub_slave aa', 'check chosen object for aa') ;
 
 
 $searcher = $root->searcher->prepare(element => 'DX');
@@ -206,7 +206,7 @@
 } ;
 
 $target = $searcher->auto_choose($cb1, sub{}) ;
-is($target->name,'warp DX', 'check auto choosen object for DX (warp)') ;
+is($target->name,'warp DX', 'check auto chosen object for DX (warp)') ;
 
 # restart and try through olist
 $searcher->reset ;
