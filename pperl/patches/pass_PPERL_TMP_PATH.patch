--- a/t/env.plx
+++ b/t/env.plx
@@ -1,3 +1,3 @@
 #!perl -w
 use strict;
-print map { "'$_' => '$ENV{$_}'\n" } sort keys %ENV;
\ No newline at end of file
+print map { "'$_' => '$ENV{$_}'\n" } sort grep { $_ ne 'PPERL_TMP_PATH' } keys %ENV;
--- a/PPerl.pm
+++ b/PPerl.pm
@@ -30,7 +30,7 @@ PPerl - Make perl scripts persistent in 
 
 This program turns ordinary perl scripts into long running daemons, making
 subsequent executions extremely fast. It forks several processes for each
-script, allowing many proceses to call the script at once.
+script, allowing many processes to call the script at once.
 
 It works a lot like SpeedyCGI, but is written a little differently. I didn't
 use the SpeedyCGI codebase, because I couldn't get it to compile, and needed
@@ -75,6 +75,13 @@ You need to make sure the path to the sc
 Alternatively look for a .pid file for the script in your tmp directory, and
 kill (with SIGINT) the process with that PID.
 
+=head1 ENVIRONMENT
+
+B<pperl> uses the B<PPERL_TMP_PATH> environment variable to determine
+the directory where to store the files used for inter-process
+communication.  By default, the subdirectory I<.pperl> of the user's
+home directory is used.
+
 =head1 BUGS
 
 The process does not reload when the script or modules change.
--- a/t/04args.t
+++ b/t/04args.t
@@ -17,9 +17,11 @@ ok(capture('./pperl', 't/args.plx', "foo
 
 `./pperl t/env.plx`; # run it once so there's a $ENV{PATH} about
 
+my $tmp_path = $ENV{PPERL_TMP_PATH};
 %ENV = ( foo       => "bar\nbaz",
          "quu\nx"  => "wobble",
          null      => '');
+$ENV{PPERL_TMP_PATH} = $tmp_path if $tmp_path;
 
 ok(capture($^X, 't/env.plx'),
   qq{'foo' => 'bar\nbaz'\n'null' => ''\n'quu\nx' => 'wobble'\n});
